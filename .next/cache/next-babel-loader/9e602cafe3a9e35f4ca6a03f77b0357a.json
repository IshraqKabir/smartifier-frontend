{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useEffect, useState } from \"react\";\nimport useLocalState from \"../../../custom-hooks/useLocalState\";\nimport submitTest from \"../../../repository/QuizTest/submitTest\";\nexport default function useTestState(quizId, questions, test, duration) {\n  const [user] = useLocalState(\"user\", \"\");\n  const [answers, setAnswersState] = useLocalState(`${user === null || user === void 0 ? void 0 : user.email}-test${test === null || test === void 0 ? void 0 : test.id}-answers`, {});\n  const {\n    0: currentQuestionIndex,\n    1: setCurrentQuestionIndex\n  } = useState(0);\n  const {\n    0: progress,\n    1: setProgress\n  } = useState(getProgress());\n  const {\n    0: secondsRemaining,\n    1: setSecondsRemaining\n  } = useState(() => {\n    if (!test) return 600;\n    return getTimeRemainingInSeconds(test === null || test === void 0 ? void 0 : test.created_at, duration.toString());\n  });\n  const {\n    0: timeRemaining,\n    1: setTimeRemaing\n  } = useState(\"\");\n  const {\n    0: showSubmitButton,\n    1: setShowSubmitButton\n  } = useState(false);\n  const {\n    0: isSubmitting,\n    1: setIsSubmitting\n  } = useState(false);\n  useEffect(() => {\n    setInterval(() => {\n      setSecondsRemaining(getTimeRemainingInSeconds(test === null || test === void 0 ? void 0 : test.created_at, duration));\n    }, 500);\n  }, []);\n  useEffect(() => {\n    if (secondsRemaining <= 0) {\n      handleSubmit();\n      setTimeRemaing(\"Test Finished\");\n    } else {\n      setTimeRemaing(parseSecondsToClock(secondsRemaining));\n    }\n  }, [secondsRemaining]);\n  useEffect(() => {\n    setProgress(getProgress());\n\n    if (currentQuestionIndex == (questions === null || questions === void 0 ? void 0 : questions.length) - 1) {\n      setShowSubmitButton(true);\n    } else {\n      setShowSubmitButton(false);\n    }\n  }, [currentQuestionIndex]);\n\n  const setAnswers = (optionId, question, text) => {\n    setAnswersState(state => {\n      let tempAnswers = _objectSpread({}, state);\n\n      if (question.answer_type === \"multiple_choice\") {\n        const options = tempAnswers[`${question === null || question === void 0 ? void 0 : question.id}`];\n\n        if (!options || Array.isArray(options) && !options[0]) {\n          tempAnswers = _objectSpread(_objectSpread({}, state), {}, {\n            [`${question === null || question === void 0 ? void 0 : question.id}`]: [{\n              optionId: optionId\n            }]\n          });\n        }\n\n        if (options && Array.isArray(options) && options[0]) {\n          var _options$;\n\n          if (((_options$ = options[0]) === null || _options$ === void 0 ? void 0 : _options$.optionId) == optionId) {\n            tempAnswers = _objectSpread(_objectSpread({}, state), {}, {\n              [`${question === null || question === void 0 ? void 0 : question.id}`]: []\n            });\n          } else {\n            tempAnswers = _objectSpread(_objectSpread({}, state), {}, {\n              [`${question === null || question === void 0 ? void 0 : question.id}`]: [{\n                optionId: optionId\n              }]\n            });\n          }\n        }\n      } else if ((question === null || question === void 0 ? void 0 : question.answer_type) === \"checkboxes\") {\n        const options = tempAnswers[`${question === null || question === void 0 ? void 0 : question.id}`];\n\n        if (!options || Array.isArray(options) && !options[0]) {\n          tempAnswers = _objectSpread(_objectSpread({}, state), {}, {\n            [`${question === null || question === void 0 ? void 0 : question.id}`]: [{\n              optionId: optionId\n            }]\n          });\n        }\n\n        if (options && Array.isArray(options)) {\n          let includes = false;\n          options === null || options === void 0 ? void 0 : options.forEach(option => {\n            if ((option === null || option === void 0 ? void 0 : option.optionId) == optionId) {\n              includes = true;\n            }\n          });\n\n          if (includes) {\n            tempAnswers = _objectSpread(_objectSpread({}, state), {}, {\n              [`${question === null || question === void 0 ? void 0 : question.id}`]: options === null || options === void 0 ? void 0 : options.filter(option => {\n                return (option === null || option === void 0 ? void 0 : option.optionId) != optionId;\n              })\n            });\n          } else {\n            tempAnswers = _objectSpread(_objectSpread({}, state), {}, {\n              [`${question === null || question === void 0 ? void 0 : question.id}`]: [...options, {\n                optionId: optionId\n              }]\n            });\n          }\n        }\n      } else if ((question === null || question === void 0 ? void 0 : question.answer_type) === \"short_paragraph\") {\n        if (!text) return _objectSpread({}, tempAnswers);\n        tempAnswers = _objectSpread(_objectSpread({}, state), {}, {\n          [`${question === null || question === void 0 ? void 0 : question.id}`]: [{\n            optionId: optionId,\n            text: text\n          }]\n        });\n      }\n\n      return _objectSpread({}, tempAnswers);\n    });\n  };\n\n  const goToNextQuestion = () => {\n    if (currentQuestionIndex >= (questions === null || questions === void 0 ? void 0 : questions.length) - 1) return;\n    setCurrentQuestionIndex(currentQuestionIndex + 1);\n  };\n\n  const goToPreviousQuestion = () => {\n    if (currentQuestionIndex <= 0) return;\n    setCurrentQuestionIndex(currentQuestionIndex - 1);\n  };\n\n  const showPrevious = currentQuestionIndex != 0;\n  const showNext = currentQuestionIndex < (questions === null || questions === void 0 ? void 0 : questions.length) - 1;\n\n  function getProgress() {\n    if ((questions === null || questions === void 0 ? void 0 : questions.length) == 0) return 100;\n    return (currentQuestionIndex + 1) * 100 / (questions === null || questions === void 0 ? void 0 : questions.length);\n  }\n\n  async function handleSubmit() {\n    var _Object$values;\n\n    if (!answers) alert(\"Not enough answers to submit!\");\n    setIsSubmitting(true);\n    const processedAnswers = [];\n    (_Object$values = Object.values(answers)) === null || _Object$values === void 0 ? void 0 : _Object$values.forEach(answer => {\n      if (answer && Array.isArray(answer)) {\n        answer === null || answer === void 0 ? void 0 : answer.forEach(option => {\n          if (option === null || option === void 0 ? void 0 : option.optionId) {\n            processedAnswers.push({\n              optionId: option === null || option === void 0 ? void 0 : option.optionId,\n              text: (option === null || option === void 0 ? void 0 : option.text) ? option === null || option === void 0 ? void 0 : option.text : \"\"\n            });\n          }\n        });\n      }\n    });\n    const response = await submitTest(test === null || test === void 0 ? void 0 : test.id, processedAnswers, user === null || user === void 0 ? void 0 : user.token);\n\n    if (response.error || response == \"error\") {\n      alert(\"Something went wrong. Please refresh and submit the test.\");\n      return;\n    }\n\n    setAnswersState({});\n    window.location.href = `/user/profile`; // window.location.href = `/test/${test?.id}/result`;\n\n    setIsSubmitting(false);\n  }\n\n  return {\n    answers,\n    setAnswers,\n    progress,\n    currentQuestionIndex,\n    goToNextQuestion,\n    goToPreviousQuestion,\n    showPrevious,\n    showNext,\n    timeRemaining,\n    secondsRemaining,\n    showSubmitButton,\n    isSubmitting,\n    handleSubmit\n  };\n}\n\nfunction getTimeRemainingInSeconds(start_time, duration) {\n  const totalDurationInSeconds = getSecondsFromDuration(duration);\n  const start = new Date(`${start_time}`);\n  const now = new Date();\n  const end = new Date(`${start_time}`);\n  end.setTime(start.getTime() + totalDurationInSeconds * 1000);\n  const secondsLeft = (end.getTime() - now.getTime()) / 1000;\n  return Math.floor(secondsLeft);\n}\n\nfunction getSecondsFromDuration(duration) {\n  const [hours, mins, seconds] = duration.split(\":\");\n  let totalSeconds = 0;\n  totalSeconds += parseInt(hours) * 60 * 60;\n  totalSeconds += parseInt(mins) * 60;\n  totalSeconds += parseInt(seconds);\n  return totalSeconds;\n}\n\nfunction parseSecondsToClock(secondsRemaining) {\n  const mins = Math.floor(secondsRemaining / 60);\n  const seconds = Math.floor(secondsRemaining % 60);\n  return `${mins < 10 ? `0${mins}` : mins}:${seconds < 10 ? `0${seconds}` : seconds}`;\n}","map":null,"metadata":{},"sourceType":"module"}